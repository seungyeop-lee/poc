# 고수준 작업 계획 (High-Level Plan)

## 작업 접근 방법

### 1단계: 정보 수집

**수집할 정보**:
- 프로젝트의 현재 디렉토리 구조 및 기존 파일 유무
- package.json 존재 여부 및 현재 설치된 의존성
- CouponEmbeddingSettings 인터페이스의 정의 (기존 타입 정의 파일 확인)
- Node.js 및 npm 버전 확인
- Sharp 라이브러리의 텍스트 오버레이 관련 API 문서 확인
- React 프로젝트 설정 방식 (Create React App, Vite 등) 결정을 위한 현황 파악

**수집 방법**:
- 작업 디렉토리 탐색 및 파일 구조 확인
- package.json, tsconfig.json 등 설정 파일 읽기
- 인터페이스 정의 파일 검색
- 시스템 환경 확인

**예상 결과물**:
- 현재 프로젝트 구조 파악 문서
- 기존 설정 파일 목록
- 필요한 라이브러리 및 도구 목록
- CouponEmbeddingSettings 인터페이스 구조

### 2단계: 분석

**분석 대상**:
- 백엔드와 프론트엔드 간 API 통신 구조
- Sharp 라이브러리의 텍스트 오버레이 구현 방법 (텍스트, 위치, 폰트 설정)
- React에서 이미지 업로드 및 드래그 앤 드롭 구현 방법
- 설정값 변경 시 서버 측 Sharp 호출 및 프리뷰 이미지 갱신 플로우
- CouponEmbeddingSettings 인터페이스의 모든 속성이 Sharp API에 어떻게 매핑되는지
- 이미지 포맷(JPEG, PNG, WebP) 지원 방식

**분석 방법**:
- Sharp 라이브러리의 composite() 및 텍스트 렌더링 API 조사
- React에서 파일 업로드, 폼 입력, 드래그 이벤트 처리 패턴 분석
- 서버-클라이언트 간 이미지 전송 방식 분석 (Base64, Blob URL, 멀티파트 등)
- 실시간 프리뷰 업데이트를 위한 API 엔드포인트 설계

**예상 결과물**:
- API 엔드포인트 설계 초안
- Sharp 텍스트 오버레이 구현 방법 문서
- React UI 컴포넌트 구조 초안
- 데이터 흐름 다이어그램 (이미지 업로드 → 설정 입력 → 서버 처리 → 프리뷰 표시)
- CouponEmbeddingSettings 속성별 Sharp API 매핑 테이블

### 3단계: 설계

**설계 영역**:
- 백엔드 서버 아키텍처 (Express 또는 Fastify 선택)
- API 엔드포인트 정의
  - POST /upload: 템플릿 이미지 업로드
  - POST /preview: 텍스트 오버레이 프리뷰 이미지 생성
  - POST /download: 최종 이미지 생성 및 다운로드
- CouponEmbeddingSettings TypeScript 인터페이스 정의
- React 컴포넌트 구조
  - ImageUploadComponent: 이미지 업로드 UI
  - SettingsFormComponent: 텍스트 및 설정값 입력 폼
  - PreviewCanvasComponent: 드래그 앤 드롭 및 프리뷰 표시
- 드래그 앤 드롭 로직 설계 (마우스 이벤트 처리, 좌표 계산, 상태 업데이트)
- 양방향 동기화 메커니즘 (설정값 → 프리뷰, 드래그 → 설정값)

**설계 방법**:
- 백엔드는 Express 프레임워크 기반, multer로 파일 업로드 처리
- Sharp를 이용한 텍스트 오버레이는 SVG 텍스트 생성 후 composite() 사용
- React 상태 관리는 useState로 단순화, 필요 시 useReducer 고려
- 드래그 앤 드롭은 HTML5 Canvas API 또는 div 기반 인터랙션
- 프리뷰 업데이트는 설정값 변경 시 debounce 적용 후 서버 요청

**설계 산출물**:
- API 명세서 (엔드포인트, 요청/응답 형식)
- CouponEmbeddingSettings 인터페이스 TypeScript 코드
- React 컴포넌트 계층 구조 다이어그램
- 드래그 앤 드롭 이벤트 핸들러 의사 코드
- Sharp 텍스트 오버레이 구현 코드 스니펫

### 4단계: 구현

**구현 작업**:
- 작업 1: Node.js 백엔드 서버 기본 구조 구축
  - Express 설치 및 서버 초기화
  - Sharp, multer 설치
  - 기본 라우팅 설정
- 작업 2: CouponEmbeddingSettings 인터페이스 정의 및 Sharp 텍스트 오버레이 로직 구현
  - TypeScript 인터페이스 파일 작성
  - Sharp를 이용한 텍스트 렌더링 함수 구현
  - 이미지 업로드 엔드포인트 구현
  - 프리뷰 생성 엔드포인트 구현
- 작업 3: React 프론트엔드 프로젝트 생성 및 기본 UI 구현
  - React 프로젝트 초기화 (Vite 또는 Create React App)
  - 이미지 업로드 컴포넌트 구현
  - 설정값 입력 폼 컴포넌트 구현
  - 프리뷰 영역 기본 레이아웃 구현
- 작업 4: 드래그 앤 드롭 인터랙션 구현
  - Canvas 또는 div 기반 드래그 이벤트 핸들러 구현
  - 마우스 좌표를 이미지 내 픽셀 좌표로 변환하는 로직 구현
  - 드래그 시 left, top 상태 실시간 업데이트
- 작업 5: 설정값과 프리뷰 간 양방향 동기화 구현
  - 설정값 변경 시 서버로 프리뷰 요청 전송 (debounce 적용)
  - 서버에서 받은 프리뷰 이미지를 화면에 표시
  - 드래그 이동 시 설정값 폼 자동 업데이트
- 작업 6: 이미지 다운로드 기능 구현
  - 최종 이미지 생성 엔드포인트 구현
  - 프론트엔드에서 다운로드 버튼 클릭 시 이미지 다운로드

**구현 순서**:
1. 백엔드 기본 구조 및 Sharp 로직 구현: 프리뷰 생성의 핵심 기능이므로 먼저 구현
2. React 프론트엔드 기본 UI 구현: 백엔드 API를 호출할 UI가 필요
3. 드래그 앤 드롭 인터랙션 구현: 프리뷰 영역이 준비된 후 추가
4. 양방향 동기화 및 다운로드 기능 구현: 모든 기본 기능이 완성된 후 통합

**구현 방법**:
- 백엔드는 Express로 RESTful API 구성, Sharp로 이미지 처리
- 프론트엔드는 React 함수형 컴포넌트 및 hooks 사용
- 파일 업로드는 FormData로 전송, 프리뷰 이미지는 Blob URL로 표시
- 드래그 앤 드롭은 onMouseDown, onMouseMove, onMouseUp 이벤트 조합

### 5단계: 검증

**검증 항목**:
- 이미지 업로드 기능: JPEG, PNG, WebP 파일 업로드 후 화면에 표시되는지 확인
- 텍스트 입력 및 설정값 반영: 각 CouponEmbeddingSettings 속성 변경 시 프리뷰가 즉시 업데이트되는지 확인
- 드래그 앤 드롭: 텍스트를 드래그하여 이동 시 left, top 값이 정확히 변경되는지 확인
- 양방향 동기화: 폼에서 left, top 값을 직접 입력해도 프리뷰가 정확히 이동하는지 확인
- 이미지 다운로드: 다운로드한 이미지에 텍스트가 정확히 오버레이되어 있는지 확인
- 모든 이미지 포맷 지원: JPEG, PNG, WebP 각각 테스트

**테스트 계획**:
- 수동 테스트: 각 기능을 브라우저에서 직접 조작하며 확인
- 경계값 테스트: left, top을 이미지 경계 밖으로 설정 시 동작 확인
- 다양한 폰트 설정 조합 테스트: fontFamily, fontWeight, fontSize, fontColor 변경 시 정상 렌더링 확인
- 서버 에러 핸들링 테스트: 잘못된 이미지 파일 업로드, 잘못된 설정값 전송 시 에러 처리 확인

**완료 확인 방법**:
- 명세서의 기능 완료 기준 5개 항목을 모두 수동으로 확인하고 체크리스트로 검증
- 명세서의 품질 완료 기준 4개 항목을 실제 사용 시나리오로 검증
- 모든 테스트 케이스를 통과하면 완료로 판단

## 기술적 고려사항

**사용 기술 스택**:
- 백엔드: Node.js, Express, Sharp, multer, TypeScript
- 프론트엔드: React, TypeScript, Vite (또는 Create React App)
- 이미지 처리: Sharp 라이브러리 (서버 측)
- 파일 업로드: multer (서버), FormData (클라이언트)

**기술적 제약 및 요구사항**:
- Sharp 라이브러리 사용 필수: 텍스트 오버레이는 Sharp의 composite() 또는 SVG 렌더링 기능 활용
- CouponEmbeddingSettings 인터페이스 구조 준수: left, top, fontSize, fontColor, fontFamily, fontWeight 모두 포함
- 서버 측에서 프리뷰 업데이트 처리: 클라이언트는 설정값을 서버로 전송하고, 서버는 Sharp로 이미지 생성 후 반환
- 지원 이미지 포맷: JPEG, PNG, WebP
- 시스템 폰트만 사용: fontFamily는 시스템에 설치된 폰트명으로 제한

**기술 적용 방안**:
- Sharp의 텍스트 오버레이: SVG 문자열을 생성하여 composite()로 합성
- React 상태 관리: CouponEmbeddingSettings를 useState로 관리, 변경 시 서버 요청
- 드래그 앤 드롭: Canvas API 또는 절대 위치 div를 이용한 인터랙션
- 프리뷰 레이턴시 최소화: debounce로 서버 요청 빈도 조절, 이미지 크기 최적화

## 리스크 및 대응 방안

**식별된 리스크**:
- 리스크 1: Sharp의 텍스트 렌더링 API 제약으로 인한 fontFamily, fontWeight 미지원 가능성
  - Sharp는 직접적인 텍스트 렌더링 API가 제한적이므로, SVG를 이용한 우회 방법 필요
- 리스크 2: 시스템 폰트만 사용하므로 사용자 환경에 따라 폰트가 다르게 렌더링될 수 있음
  - 서버 환경에 설치된 폰트로 제한되므로, 폰트 목록을 미리 확인하고 기본값 설정 필요
- 리스크 3: 드래그 앤 드롭 시 이미지 스케일링으로 인한 좌표 변환 오류 가능성
  - 프리뷰 화면의 이미지가 원본 크기와 다를 경우, 드래그 좌표를 원본 이미지 좌표로 정확히 변환해야 함
- 리스크 4: 프리뷰 업데이트 시 서버 응답 지연으로 인한 사용자 경험 저하
  - 설정값 변경마다 서버 요청을 보내면 네트워크 지연 발생 가능

**대응 전략**:
- 리스크 1에 대한 대응: Sharp의 composite()를 이용해 SVG 텍스트를 렌더링. SVG에서 font-family, font-weight 속성 지원 확인 후 적용
- 리스크 2에 대한 대응: 서버 시작 시 사용 가능한 시스템 폰트 목록을 조회하고, 프론트엔드에 전달하여 폰트 선택 UI 제한
- 리스크 3에 대한 대응: 프리뷰 이미지의 표시 크기와 원본 크기 비율을 계산하여 드래그 좌표 변환 로직에 적용
- 리스크 4에 대한 대응: debounce를 적용하여 설정값 변경 후 일정 시간(예: 300ms) 후 서버 요청. 로딩 인디케이터로 사용자에게 처리 중임을 알림

## 완료 기준

**기능적 완료 기준**:
- 템플릿 이미지 업로드 완료 조건: 이미지 파일(JPEG, PNG, WebP) 선택 시 화면에 업로드된 이미지가 프리뷰 영역에 표시됨
- 텍스트 입력 완료 조건: 텍스트 입력 필드에 값을 입력하면 프리뷰 이미지에 해당 텍스트가 오버레이되어 표시됨
- 설정값 입력 UI 완료 조건: left, top, fontSize, fontColor, fontFamily, fontWeight 각각의 입력 필드가 존재하고, 값 변경 시 프리뷰에 즉시 반영됨
- 드래그 앤 드롭 완료 조건: 프리뷰 영역에서 텍스트를 드래그하여 이동하면, left와 top 입력 필드의 값이 자동으로 업데이트됨
- 이미지 다운로드 완료 조건: 다운로드 버튼 클릭 시 텍스트가 오버레이된 최종 이미지 파일이 다운로드됨

**기술적 완료 기준**:
- Sharp 사용 충족 조건: 서버 측에서 Sharp 라이브러리를 이용해 텍스트 오버레이를 처리하고, 프리뷰 및 최종 이미지를 생성함
- CouponEmbeddingSettings 준수 조건: left, top, fontSize, fontColor, fontFamily, fontWeight 모든 속성이 TypeScript 인터페이스로 정의되고, 프리뷰 및 최종 이미지에 모두 반영됨
- 이미지 포맷 지원 조건: JPEG, PNG, WebP 형식의 이미지를 업로드하고 처리할 수 있음
- 시스템 폰트 사용 조건: fontFamily는 서버의 시스템 폰트만 사용하며, 폰트 파일 업로드는 지원하지 않음

**품질 완료 기준**:
- 드래그 앤 드롭 품질: 텍스트를 드래그할 때 부드럽게 이동하고, 마우스 포인터와 텍스트 위치가 정확히 일치함
- 프리뷰 반영 속도: 설정값 변경 후 1초 이내에 프리뷰가 업데이트됨
- 이미지 포맷 호환성: JPEG, PNG, WebP 각각의 이미지 파일로 테스트 시 모두 정상 동작함
- UI 직관성: 사용자가 별도의 설명 없이도 이미지 업로드, 텍스트 입력, 설정 조정, 드래그 이동, 다운로드 기능을 쉽게 사용할 수 있음

## 단계별 의존성

### 순차 의존성

**필수 순차 진행**:
- 1단계(정보 수집) → 2단계(분석): 현재 프로젝트 상태 및 Sharp API를 파악해야 분석 가능
- 2단계(분석) → 3단계(설계): Sharp 텍스트 오버레이 방법 및 데이터 흐름을 분석한 후 설계 가능
- 3단계(설계) → 4단계(구현): API 명세, 컴포넌트 구조, 드래그 로직이 설계된 후 구현 가능
- 4단계(구현) → 5단계(검증): 구현이 완료되어야 기능 및 품질 검증 가능

**각 단계의 전제조건**:
- 2단계(분석):
  - 필요 산출물: 프로젝트 구조 파악, Sharp API 문서, CouponEmbeddingSettings 인터페이스 구조
  - 확인 사항: 백엔드 서버 구현 방식 결정, React 프로젝트 초기화 방식 결정
- 3단계(설계):
  - 필요 산출물: Sharp 텍스트 오버레이 구현 방법, React UI 컴포넌트 구조 초안, 데이터 흐름 다이어그램
  - 확인 사항: API 엔드포인트 설계 완료, 드래그 앤 드롭 로직 설계 완료
- 4단계(구현):
  - 필요 산출물: API 명세서, React 컴포넌트 계층 구조, Sharp 텍스트 오버레이 코드 스니펫
  - 확인 사항: 백엔드 서버 초기화 완료, React 프로젝트 초기화 완료
- 5단계(검증):
  - 필요 산출물: 모든 기능이 구현된 백엔드 서버 및 프론트엔드 애플리케이션
  - 확인 사항: 이미지 업로드, 설정값 입력, 드래그 앤 드롭, 프리뷰 업데이트, 이미지 다운로드 기능이 모두 동작함

### 병렬 처리 가능 영역

- 병렬 그룹 1 (4단계 구현 내 작업 1과 작업 3):
  - 작업 1 (백엔드 서버 기본 구조 구축): 백엔드는 독립적으로 구현 가능
  - 작업 3 (React 프론트엔드 프로젝트 생성 및 기본 UI 구현): 프론트엔드는 백엔드 API 설계만 완료되면 독립적으로 구현 가능
- 병렬 그룹 2 (4단계 구현 내 작업 4와 작업 5 일부):
  - 작업 4 (드래그 앤 드롭 인터랙션 구현): 프리뷰 영역 기본 레이아웃이 완료되면 독립적으로 구현 가능
  - 작업 5의 설정값 → 프리뷰 동기화: 프리뷰 API 엔드포인트가 완료되면 독립적으로 구현 가능

### 단계 간 연결점

**연결점 정의**:
- 1단계 → 2단계:
  - 완료 조건: 프로젝트 구조, 기존 파일, CouponEmbeddingSettings 인터페이스, Sharp API 문서가 모두 수집됨
  - 전달 산출물: 현재 프로젝트 구조 문서, 필요 라이브러리 목록, 인터페이스 구조
- 2단계 → 3단계:
  - 완료 조건: API 통신 구조, Sharp 텍스트 오버레이 구현 방법, React 드래그 앤 드롭 구현 방법, CouponEmbeddingSettings 속성별 Sharp API 매핑이 모두 분석됨
  - 전달 산출물: API 엔드포인트 설계 초안, Sharp 구현 방법 문서, React UI 컴포넌트 구조 초안, 데이터 흐름 다이어그램
- 3단계 → 4단계:
  - 완료 조건: 백엔드 아키텍처, API 엔드포인트, CouponEmbeddingSettings 인터페이스, React 컴포넌트 구조, 드래그 앤 드롭 로직이 모두 설계됨
  - 전달 산출물: API 명세서, TypeScript 인터페이스 코드, React 컴포넌트 계층 구조, 드래그 이벤트 핸들러 의사 코드, Sharp 텍스트 오버레이 코드 스니펫
- 4단계 → 5단계:
  - 완료 조건: 백엔드 서버, Sharp 텍스트 오버레이 로직, React UI, 드래그 앤 드롭, 양방향 동기화, 이미지 다운로드 기능이 모두 구현됨
  - 전달 산출물: 동작하는 백엔드 서버, 동작하는 React 프론트엔드 애플리케이션